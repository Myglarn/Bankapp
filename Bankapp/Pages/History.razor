@page "/History"
@using Bankapp.Domain
@inject IAccountservice Accountservice;
<!--Kommentarer -->
<h3>Account History</h3>

@if (_accounts.Count == 0)
{
	<p>No accounts</p>
}
else
{
	{/*Blabla*/}
	<div class="form-row">
		<label>Choose account</label>
		<InputSelect TValue="Guid" class="form-select" id="accountSelect" @bind-Value="SelectedAccountId">
			@foreach (var account in _accounts)
		{
			<option value="@account.Id">@account.Name - Balance: @account.Balance</option>
		}
		</InputSelect>
	</div>

	
	@if (!_selectedAccount.Transactions.Any())
	{
		<p>No transactions found</p>
	}
	else
	{
		<table class="table table-sm">
			<thead>
				<tr>
					<th>
						<button class="btn btn-sm" @onclick="() => SetSort(SortKey.Date)">
							Sort: Date @(currentKey == SortKey.Date ? (descending ? "⯆" : "⯅") : "")
						</button>
					</th>
					<th>
						<button class="btn btn-sm" @onclick="() => SetSort(SortKey.Amount)">
							Sort: Amount @(currentKey == SortKey.Amount ? (descending ? "⯆" : "⯅") : "")
						</button>
					</th>
					<th>
						<button class="btn btn-sm" @onclick="() => SetSort(SortKey.TransactionType)">
							Sort: Transaction Type @(currentKey == SortKey.TransactionType ? (descending ? "⯆" : "⯅") : "")
						</button>
					</th>
					<th>
						<button class="btn btn-sm" @onclick="() => SetSort(SortKey.BalanceAfterTransaction)">
							Sort: Balance after transaction @(currentKey == SortKey.BalanceAfterTransaction ? (descending ? "⯆" : "⯅") : "")
						</button>
					</th>
					<th>From -> To</th>					
				</tr>
			</thead>
			<tbody>
				@foreach(var transaction in sortedTransaction())
				{
					<tr>
						<td>@transaction.DateTimeNow.ToLocalTime().ToString("yyyy-MM-dd HH:mm")</td>
						<td>@transaction.Amount</td>
						<td>@transaction.TransactionType</td>
						<td>@transaction.BalanceAfterTransaction</td>
					
                        <td>
							@if (transaction.FromAccount.HasValue && transaction.ToAccount.HasValue)
							{
								<span>@(transaction.FromAccount.Value.ToString()[..4]) -> @(transaction.ToAccount.Value.ToString()[..4])</span>
							}
							else if (transaction.FromAccount.HasValue)
							{
								<span>@(transaction.FromAccount.Value.ToString()[..4]) -> --</span>
							}
							else if (transaction.ToAccount.HasValue)
							{
								<span>-- -> @(transaction.ToAccount.Value.ToString()[..4])</span>
							}
							else
							{
								<span>--</span>
							}
                        </td>
					</tr>
				}
			</tbody>
		</table>
	}

}
<!--Code for the deisgn-->
@code{
	//Instance variables
	private List<Bankaccount> _accounts = new();
	private List<Transaction>? _transactions = new();
	private SortKey currentKey = SortKey.Date;
	private IBankaccount? _selectedAccount;
	private Guid _selectedAccountId;

	//startvärde för sorteringen

	private bool descending = true;

	//Sorteringsvarianter
	private enum SortKey
	{
		Date,
		Amount,
		TransactionType,
		BalanceAfterTransaction
	}

	private void SetSort(SortKey sortKey)
	{
		if (currentKey == sortKey)
		{
			descending = !descending;
		}
		else
		{
			currentKey = sortKey;
			descending = true;
		}
	}

	private Guid SelectedAccountId
	{
		get => _selectedAccountId;
		set
		{
			if (_selectedAccountId == value)
				return;

			_selectedAccountId = value;
			_selectedAccount = _accounts.FirstOrDefault(account => account.Id == value);
			// _selectedAccount.Transactions
		}
	}
	protected override async Task OnInitializedAsync()
	{
		var accounts = await Accountservice.GetAccounts();
		_accounts = accounts.Cast<Bankaccount>().ToList();
		_transactions = new();
		
		//Om det finns konton i vår lista, välj första för att visa i UI
		if (_accounts.Count > 0)
		{
			_selectedAccountId = _accounts[0].Id;
			_selectedAccount = _accounts[0];
		}		
	}

	private IEnumerable<Transaction> sortedTransaction()
	{
		if (_selectedAccount == null)
		{
			return Enumerable.Empty<Transaction>();
		}
		//Sortera listan, Datum och belopp
		var sortedList = _selectedAccount.Transactions.AsEnumerable();
		sortedList = currentKey switch
		{
			SortKey.Amount => (descending ? sortedList.OrderByDescending(t => t.Amount) : sortedList.OrderBy(t => t.Amount)),
			SortKey.Date => (descending ? sortedList.OrderByDescending(t => t.DateTimeNow) : sortedList.OrderBy(t => t.DateTimeNow)),
			SortKey.TransactionType => (descending ? sortedList.OrderByDescending(t => t.TransactionType) : sortedList.OrderBy(t => t.TransactionType)),
			SortKey.BalanceAfterTransaction => (descending ? sortedList.OrderByDescending(t => t.BalanceAfterTransaction) : sortedList.OrderBy(t => t.BalanceAfterTransaction))
		};

		return sortedList;
	}
}