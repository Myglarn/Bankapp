@page "/History"
@using Bankapp.Domain
@inject IAccountservice Accountservice;

<!-- Displays the transaction history of accounts -->
<h3>Account History</h3>

@if (_accounts.Count == 0)
{
	<p>Please select an account</p>
}
else
{
	<!-- Dropdown for selecting which account to view -->
	<div class="form-row">
		<label>Choose account</label>
		<InputSelect TValue="Guid"
					 class="form-select"
					 @bind-Value="SelectedAccountId">
			<option value="@Guid.Empty">-- Select an account --</option>
			@foreach (var account in _accounts)
			{
				<option value="@account.Id">@account.Name - Balance: @account.Balance</option>
			}
		</InputSelect>
	</div>

	<!-- Filters -->
	<div class="form-row">
		<div class="col">
			<label>From date</label>
			<InputDate class="form-control" @bind-Value="filterFromDate" />
		</div>

		<div class="col">
			<label>To date</label>
			<InputDate class="form-control" @bind-Value="filterToDate" />
		</div>
		
		<div class="col">
			<label>Transaction Type</label>
			<InputSelect class="form-select" @bind-Value="filterTransactionType">
				<option value="">Filter by transaction type</option>

				<!-- Exclude "Transfer"" since it displays differently -->
				@foreach (TransactionType type in Enum.GetValues(typeof(TransactionType))
							.Cast<TransactionType>()
							.Where(t => t != TransactionType.Transfer))
				{
					<option value="@type">@type</option>
				}
			</InputSelect>
		</div>
	</div>

	@if (_selectedAccount == null)
	{
		<p>Please select an account</p>
	}
	else if (!sortedTransaction().Any())
	{
		<p>No transasctions found</p>
	}
	else if (!_selectedAccount.Transactions.Any())
	{
		<p>No transactions found</p>
	}
	else
	{
		<!-- Transaction table -->
		<table class="table table-sm">
			<thead>
				<tr>
					<th>
						<button class="btn btn-sm" @onclick="() => SetSort(SortKey.Date)">
							Sort: Date @(currentKey == SortKey.Date ?
												(descending ? "⯆" : "⯅") : "")
						</button>
					</th>
					<th>
						<button class="btn btn-sm" @onclick="() => SetSort(SortKey.Amount)">
							Sort: Amount @(currentKey == SortKey.Amount ?
										(descending ? "⯆" : "⯅") : "")
						</button>
					</th>
					<th>
						<button class="btn btn-sm" @onclick="() => SetSort(SortKey.TransactionType)">
							Sort: Transaction Type @(currentKey == SortKey.TransactionType ?
												(descending ? "⯆" : "⯅") : "")
						</button>
					</th>
					<th>
						<button class="btn btn-sm" @onclick="() => SetSort(SortKey.BalanceAfterTransaction)">
							Sort: Balance after transaction @(currentKey == SortKey.BalanceAfterTransaction ?
												(descending ? "⯆" : "⯅") : "")
						</button>
					</th>
					<th>From -> To</th>
				</tr>
			</thead>

			<tbody>
				@foreach (var transaction in sortedTransaction())
				{
					<tr>
						<td>@transaction.DateTimeNow.ToLocalTime().ToString("yyyy-MM-dd HH:mm")</td>
						<td>@transaction.Amount</td>
						<td>@transaction.TransactionType</td>
						<td>@transaction.BalanceAfterTransaction</td>
						<td>
							@if (transaction.FromAccount.HasValue && transaction.ToAccount.HasValue)
							{
								<span>@(transaction.FromAccount.Value.ToString()[..4]) -> @(transaction.ToAccount.Value.ToString()[..4])</span>
							}
							else if (transaction.FromAccount.HasValue)
							{
								<span>@(transaction.FromAccount.Value.ToString()[..4])-> -- </span>
							}
							else if (transaction.ToAccount.HasValue)
							{
								<span>-- -> @(transaction.ToAccount.Value.ToString()[..4])</span>
							}
						</td>
					</tr>
				}
			</tbody>
		</table>
	}
}

@code {
	// Instance variables
	private List<Bankaccount> _accounts = new();
	private List<Transaction>? _transactions = new();
	private SortKey currentKey = SortKey.Date;
	private IBankaccount? _selectedAccount;
	private Guid _selectedAccountId;
	private DateTime? filterFromDate;
	private DateTime? filterToDate;
	private TransactionType? filterTransactionType;	
	private bool descending = true;
	
	/// <summary>
	/// Enum for the available sort columns.
	/// </summary>
	private enum SortKey
	{
		Date,
		Amount,
		TransactionType,
		BalanceAfterTransaction
	}

	/// <summary>
	/// Changes sorting key and toggles ascending/descending.
	/// </summary>
	private void SetSort(SortKey sortKey)
	{
		if (currentKey == sortKey)
		{
			descending = !descending;
		}
		else
		{
			currentKey = sortKey;
			descending = true;
		}
	}

	/// <summary>
	/// Handles account selection from the dropdown.
	/// Also updates the currently viewed account object.
	/// </summary>
	private Guid SelectedAccountId
	{
		get => _selectedAccountId;
		set
		{
			if (_selectedAccountId == value)
			{
				return;
			}
			_selectedAccountId = value;
			_selectedAccount = _accounts.FirstOrDefault(account => account.Id == value);			
		}
	}

	/// <summary>
	/// Loads accounts on page initialization.
	/// </summary>
	protected override async Task OnInitializedAsync()
	{
		var accounts = await Accountservice.GetAccounts();
		_accounts = accounts.Cast<Bankaccount>().ToList();
		_transactions = new();
	}

	/// <summary>
	/// Returns filtered and sorted transactions for the selected account.
	/// </summary>
	private IEnumerable<Transaction> sortedTransaction()
	{
		if (_selectedAccount == null)
		{			
			return Enumerable.Empty<Transaction>();
		}

		// Apply filters
		var sortedList = _selectedAccount.Transactions.AsEnumerable();

		if (filterFromDate.HasValue)
		{
			sortedList = sortedList.Where(t => t.DateTimeNow.Date >= filterFromDate.Value.Date);			
		}
		if (filterToDate.HasValue)
		{
			sortedList = sortedList.Where(t => t.DateTimeNow.Date <= filterToDate.Value.Date);			
		}
		if (filterTransactionType.HasValue)
		{
			sortedList = sortedList.Where(t => t.TransactionType == filterTransactionType.Value);			
		}

		// Apply sorting
		sortedList = currentKey switch
		{
			SortKey.Amount => (descending ? sortedList.OrderByDescending(t => t.Amount) : sortedList.OrderBy(t => t.Amount)),
			SortKey.Date => (descending ? sortedList.OrderByDescending(t => t.DateTimeNow) : sortedList.OrderBy(t => t.DateTimeNow)),
			SortKey.TransactionType => (descending ? sortedList.OrderByDescending(t => t.TransactionType) : sortedList.OrderBy(t => t.TransactionType)),
			SortKey.BalanceAfterTransaction => (descending ? sortedList.OrderByDescending(t => t.BalanceAfterTransaction) : sortedList.OrderBy(t => t.BalanceAfterTransaction))
		};
		
		return sortedList;
	}
}